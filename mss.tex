\documentclass[twoside]{article}

\usepackage{ustj}
\renewcommand{\headrulewidth}{0pt}

\addbibresource{mss.bib}

\newcommand{\authorname}{Thomas Lindstrom-Vautrin}
\newcommand{\authorpatp}{\patp{niblyx-malnus}}
\newcommand{\affiliation}{Groundwire Syndicate}

%  Make first page footer:
\fancypagestyle{firststyle}{%
\fancyhf{}% Clear header/footer
\fancyhead{}
\fancyfoot[L]{{\footnotesize
              %% We toggle between these:
              % Manuscript submitted for review.\\
              {\it Urbit Systems Technical Journal} II:1 (2025):  47–70. \\
              ~ \\
              Address author correspondence to \authorpatp.
              }}
}
%  Arrange subsequent pages:
\fancyhf{}
% \fancyhead[LE]{{\urbitfont Urbit Systems Technical Journal}}
% \fancyhead[RO]{Deriving Nock Opcodes}
% \fancyfoot[LE,RO]{\thepage}

%%MANUSCRIPT
\title{Deriving Nock Opcodes 6–11}
\author{\authorname~\authorpatp \\ \affiliation}
\date{}

\begin{document}

\maketitle
\thispagestyle{firststyle}

\begin{abstract}
  Since Nock opcodes 0 through 5 are Turing complete, it should be possible to derive the operations of the remaining opcodes 6 through 11 from them.  In this article, we expound on this idea and provides a detailed derivation of each opcode.
\end{abstract}

% We will adjust page numbering in final editing.
\pagenumbering{arabic}
\setcounter{page}{47}

\tableofcontents

\section{Motivation}

It is a fun exercise when learning Nock to try to derive opcodes 6 through 11 with opcodes 0 through 5. We know (or suspect) that this is possible since Nocks 0 through 5 are billed as a Turing-complete ruleset. In fact, Nocks 6 through 9 and Nock 11 are quite trivial (of these, Nock 6 is the most involved) since they are defined in terms of the \lstinline[style=inlinecode]{*} tar expression evaluator and Nocks 0 through 5. It is still instructive to write these entirely as nouns which can be evaluated against some subject using the Hoon \lstinline[style=inlinecode]{.*} dottar rune. (In the following, take \lstinline[style=inlinecode]{*[a ^]} to be the same as \lstinline[style=inlinecode]{.*(a ^)}.)

Nock 10 is not expressed in this way, however. It is expressed in terms of the \lstinline[style=inlinecode]{#} hax edit operator:

\begin{lstlisting}[style=listingcode]
*[a 10 [b c] d] ==  #[b *[a c] *[a d]]
\end{lstlisting}

\noindent
While opcode 10 was introduced in the decrement from Nock 5K to Nock 4K, it is still fundamentally based on the principles established by the earlier opcodes.  Ultimately, we can express \lstinline[style=inlinecode]{#} hax in terms of opcodes 0 through 5, but we will find that it is not trivial. In fact, we have a hint as to how to do so in the definition of the \lstinline[style=inlinecode]{#} hax edit operator.

\begin{lstlisting}[style=listingblock]
#[1 a b] ============ a
#[(a + a) b c] ====== #[a [b /[(a + a + 1) c]] c]
#[(a + a + 1) b c] == #[a [/[(a + a) c] b] c]
\end{lstlisting}

\noindent
The \lstinline[style=inlinecode]{#} hax edit operator is defined in terms of the \lstinline[style=inlinecode]{/} fas slot operator, whose effect we can reproduce with base Nock opcodes using Nock 0.  As long as we have a way to keep track of whether \lstinline[style=inlinecode]{a} is odd or even, we should be able to write this code in simple Nock. We will use this insight to create our own Nock 10 from scratch.

This process will be easier using Nock opcodes 6, 7, 8, and 9, however.  So let us convince ourselves that these can be expressed as nouns composed of only Nocks 0 through 5.

\section{Deriving Opcode 7}

We  will start with Nock 7 because it is the easiest:\footnote{I use \texttt{==} and \texttt{:=} as equality and assignment operators, respectively, which are not to be confused with Hoon runes or terminators.}

\begin{lstlisting}[style=listingblock]
*[a 7 b c] == *[*[a b] c]
\end{lstlisting}

\noindent
which looks a lot like Nock 2:

\begin{lstlisting}[style=listingblock]
*[a 2 b c] == *[*[a b] *[a c]]
\end{lstlisting}

In fact, opcode 7 is basically just a glorified Nock 2 in order to allow for more direct function composition.  We can easily see that if we replace our \lstinline[style=inlinecode]{c} from Nock 2 with a \lstinline[style=inlinecode]{[1 c]} we get:

\begin{lstlisting}[style=listingblock]
*[a 2 b 1 c] == *[*[a b] *[a 1 c]] == *[*[a b] c]
\end{lstlisting}

\noindent
Therefore \lstinline[style=inlinecode]{*[a 7 b c]} and \lstinline[style=inlinecode]{*[a 2 b 1 c]} are equivalent.

\subsection*{Nock 7 Primitive Equivalent}

\begin{lstlisting}[style=listingcode]
*[a 7 b c] == *[a 2 b 1 c]
\end{lstlisting}

\section{Deriving Opcode 8}

Nock 8 is also fairly straightforward.

\begin{lstlisting}[style=listingcode]
*[a 8 b c] == *[[*[a b] a] c]
\end{lstlisting}

This extends the noun by pinning another noun \lstinline[style=inlinecode]{*[a b]} to its head, and then runs a formula \lstinline[style=inlinecode]{c} on this new noun. We notice two things here. One is function composition. First we add a noun to the head. Then we apply a formula to the new noun. This suggests Nock 7 and thus Nock 2. We also notice the creation of a cell from two nouns.

Recall the rule:

\begin{lstlisting}[style=listingcode]
*[a [b c] d] == [*[a b c] *[a d]]
\end{lstlisting}

\noindent
\lstinline[style=inlinecode]{[*[a b] a]} can be rewritten \lstinline[style=inlinecode]{[*[a b] *[a 0 1]]} which can be rewritten as \lstinline[style=inlinecode]{*[a b 0 1]}.

By substituting back into our original formula we get:

\begin{lstlisting}[style=listingblock]
*[[*[a b] a] c] ==
  *[*[a b 0 1] c] ==
  *[a 7 [b 0 1] c] ==
  *[a 2 [b 0 1] 1 c]
\end{lstlisting}

\subsection*{Nock 8 Primitive Equivalent}

\begin{lstlisting}[style=listingcode]
*[a 8 b c] == *[a 2 [b 0 1] 1 c]
\end{lstlisting}

\section{Deriving Opcode 9}

Nock 9 is the ``function invocation" opcode. It performs some function \lstinline[style=inlinecode]{c} on the subject \lstinline[style=inlinecode]{a} and then extracts the function at slot \lstinline[style=inlinecode]{b} from this new subject and runs that function against that same new subject.

\begin{lstlisting}[style=listingcode]
*[a 9 b c] == *[*[a c] 2 [0 1] 0 b]
\end{lstlisting}

\noindent
Much of the work here is already done for us. We have a formula \lstinline[style=inlinecode]{[2 [0 1] 0 b]} being applied to the result of a formula \lstinline[style=inlinecode]{c} being applied to subject \lstinline[style=inlinecode]{a}. This is just Nock 7 \lstinline[style=inlinecode]{*[a 7 c 2 [0 1] 0 b]} which is just Nock 2
\lstinline[style=inlinecode]{*[a 2 c 1 2 [0 1] 0 b]}.

\subsection*{Nock 9 Primitive Equivalent}

\begin{lstlisting}[style=listingcode]
*[a 9 b c] == *[a 2 c 1 2 [0 1] 0 b]
\end{lstlisting}

As an aside, we can note that the Nock 9 is defined in terms of a combination of pseudocode operators and Nock opcodes. We can also go the other way to see what Nock 9 looks like in pure pseudocode operators.

\begin{lstlisting}[style=listingblock]
*[a 9 b c]
== *[*[a c] 2 [0 1] 0 b]
== *[*[*[a c] 0 1] *[*[a c] 0 b]]
== *[*[a c] /[b *[a c]]]
\end{lstlisting}

\subsection*{Nock 9 Pseudocode Operator Equivalent}

\begin{lstlisting}[style=listingcode]
*[a 9 b c] == *[*[a c] /[b *[a c]]]
\end{lstlisting}

\section{Deriving Opcode 6}

Of all the opcodes so far, Nock 6 is the most complex. It is the if-then-else operator in Nock. It takes a function \lstinline[style=inlinecode]{b} which computes a loobean \lstinline[style=inlinecode]{*[a b]} on subject \lstinline[style=inlinecode]{a} and returns \lstinline[style=inlinecode]{*[a c]} if the loobean is yes (\lstinline[style=inlinecode]{0}) and \lstinline[style=inlinecode]{*[a d]} if the loobean is no (\lstinline[style=inlinecode]{1}).

\begin{lstlisting}[style=listingblock]
*[a 6 b c d] == *[a *[[c d] 0 *[[2 3] 0 *[a 4 4 b]]]]
\end{lstlisting}

\noindent
Instead of working backwards from this formula, let's derive it ourselves. First, let's select \lstinline[style=inlinecode]{c} or \lstinline[style=inlinecode]{d} from a cell \lstinline[style=inlinecode]{[c d]} based on whether \lstinline[style=inlinecode]{*[a b]} is \lstinline[style=inlinecode]{0} or \lstinline[style=inlinecode]{1}. If \lstinline[style=inlinecode]{*[a b]} is \lstinline[style=inlinecode]{0} we want to slot into the head of \lstinline[style=inlinecode]{[c d]} at address \lstinline[style=inlinecode]{2} and if \lstinline[style=inlinecode]{*[a b]} is \lstinline[style=inlinecode]{1} we want to slot into the tail of \lstinline[style=inlinecode]{[c d]} at address \lstinline[style=inlinecode]{3}. With \lstinline[style=inlinecode]{*[a 4 4 b] == ++*[a b]} we get address \lstinline[style=inlinecode]{2} from loobean \lstinline[style=inlinecode]{0} and address \lstinline[style=inlinecode]{3} from loobean \lstinline[style=inlinecode]{1}. To slot into \lstinline[style=inlinecode]{[c d]} let's simply do \lstinline[style=inlinecode]{*[[c d] 0 *[a 4 4 b]]}. This gives us either \lstinline[style=inlinecode]{c} or \lstinline[style=inlinecode]{d} which we then want to apply to \lstinline[style=inlinecode]{a}:

\begin{lstlisting}[style=listingblock]
*[a *[[c d] 0 *[[a 4 4 b]]]]
\end{lstlisting}

\noindent
We are almost there, but where does the \lstinline[style=inlinecode]{*[2 3] 0 *[a 4 4 b]} come from? Isn't slotting into \lstinline[style=inlinecode]{[2 3]} with \lstinline[style=inlinecode]{2} or \lstinline[style=inlinecode]{3} from \lstinline[style=inlinecode]{*[a 4 4 b]} redundant? We get the same value back. However, if for some reason \lstinline[style=inlinecode]{*[a b]} is not a loobean but is still an atom, meaning it is an integer greater than \lstinline[style=inlinecode]{1} and if \lstinline[style=inlinecode]{[c d]} is a noun with many nested cells, \lstinline[style=inlinecode]{*[a 4 4 b]} will return an address greater than \lstinline[style=inlinecode]{3} which could still be a valid address. \lstinline[style=inlinecode]{*[[2 3] 0 *[a 4 4 b]]} forces this to return either \lstinline[style=inlinecode]{2} or \lstinline[style=inlinecode]{3} or to crash.

Thus

\begin{lstlisting}[style=listingblock]
*[a *[[c d] 0 *[[2 3] 0 *[a 4 4 b]]]]
\end{lstlisting}

\noindent
or

\begin{lstlisting}[style=listingblock]
if *[a b] then *[a c] else *[a d]
\end{lstlisting}

\subsection*{Converting Opcode 6 to Opcodes 0 through 5}

To convert this to a single noun is straightforward enough, but it's a bit of a grind. To keep things as clean as possible, like in ~timluc-miptev's piece,\footnote{See \patp{timluc-miptev}, pp.~1--45 in this volume.} we will use variables in the dojo. Here is where we start:

\begin{lstlisting}[style=listingcode]
*[a 6 b c d] == *[a *[[c d] 0 *[[2 3] 0 *[a 4 4 b]]]]
\end{lstlisting}

Let's start at the end. In order to construct \lstinline[style=inlinecode]{[0 *[a 4 4 b]]} on subject \lstinline[style=inlinecode]{a}, let's notice that it is a cell. When trying to construct a cell with respect to a subject \lstinline[style=inlinecode]{a} we want to put it in the form \lstinline[style=inlinecode]{[*[a m] *[a n]]} so that we can recover the original expression \lstinline[style=inlinecode]{*[a m n]}. The tail of our cell is already in the form \lstinline[style=inlinecode]{*[a n]}. So how about the head? \lstinline[style=inlinecode]{*[a 1 0] == 0}. So we can write:

\begin{lstlisting}[style=listingblock]
[0 *[a 4 4 b]] == [*[a 1 0] *[a 4 4 b]] == *[a [1 0] 4 4 b]
\end{lstlisting}

\noindent
Let's say \lstinline[style=inlinecode]{=x [[1 0] 4 4 b]}. This gives us:

\begin{lstlisting}[style=listingblock]
[0 *[a 4 4 b]] == *[a x]
\end{lstlisting}

\noindent
Excellent. We have started to simplify our expression. We now have:

\begin{lstlisting}[style=listingblock]
*[a 6 b c d] == *[a *[[c d] 0 *[[2 3] *[a x]]]]
\end{lstlisting}

\noindent
Hopefully you see how can we can repeat this process. Let's look at \lstinline[style=inlinecode]{*[[2 3] *[a x]]}. This has nested expression evaluations. This suggests Nock 2. For Nock 2, we want to get our expression in the form \lstinline[style=inlinecode]{*[*[a m] *[a n]]} so that we can recover the original expression \lstinline[style=inlinecode]{*[a 2 m n]}. (This looks like what we did in our first step, but don't be fooled. In the first step we were building a cell. In this step, we are building an expression evaluation.) Notice that \lstinline[style=inlinecode]{[2 3] == *[a 1 2 3]}. This gives us:

\begin{lstlisting}[style=listingblock]
*[[2 3] *[a x]] ==
  *[*[a 1 2 3] *[a x]] ==
  *[a 2 [1 2 3] x]
\end{lstlisting}

Let's say \lstinline[style=inlinecode]{=y [2 [1 2 3] x]}. This gives us:

\begin{lstlisting}[style=listingblock]
*[[2 3] *[a x]] == *[a y]
\end{lstlisting}

\noindent
We now have:

\begin{lstlisting}[style=listingcode]
*[a 6 b c d] == *[a *[[c d] 0 *[a y]]]
\end{lstlisting}

Let's look at \lstinline[style=inlinecode]{[0 *[a y]]}. Another cell. We know what to do here.

\begin{lstlisting}[style=listingblock]
[0 *[a y]] == [*[a 1 0] *[a y]] == *[a [1 0] y]
\end{lstlisting}

So we now have:

\begin{lstlisting}[style=listingblock]
*[a 6 b c d] == *[a *[[c d] *[a [1 0] y]]]
\end{lstlisting}

\noindent
\lstinline[style=inlinecode]{*[[c d] *[a [1 0] y]]} has nested expression evaluations. We know what to do here.

\begin{lstlisting}[style=listingblock]
*[[c d] *[a [1 0] y]] ==
  *[*[a 1 c d] *[a [1 0] y]] ==
  *[a 2 [1 c d] [1 0] y]
\end{lstlisting}

\noindent
This is starting to get a little verbose again. Let's substitute:
\lstinline[style=inlinecode]{=z [2 [1 c d] [1 0] y]}. This gives us:

\begin{lstlisting}[style=listingblock]
*[[c d] 0 *[[2 3] 0 *[a 4 4 b]]] ==
  *[[c d] 0 *[a y]] == *[a z]
\end{lstlisting}

\noindent
So now we have:

\begin{lstlisting}[style=listingblock]
*[a 6 b c d] == *[a *[a z]]
\end{lstlisting}

\noindent
More nested evaluation expressions.

\begin{lstlisting}[style=listingblock]
*[a *[a z]] == *[*[a 0 1] *[a z]] == *[a 2 [0 1] z]
\end{lstlisting}

\noindent
Finally, we have:

\begin{lstlisting}[style=listingblock]
*[a 6 b c d] == *[a 2 [0 1] z]
\end{lstlisting}

\noindent
And that's the whole expression. Let's substitute back in:

\begin{lstlisting}[style=listingblock]
*[a 2 [0 1] z] == *[a 2 [0 1] 2 [1 c d] [1 0] y] ==
  *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] x] ==
  *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]
\end{lstlisting}

\noindent
This is Nock 6 written with only Nock 0 through 5.

\subsection*{Nock 6 Primitive Equivalent}

\begin{lstlisting}[style=listingcode]
*[a 6 b c d] ==
  *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]
\end{lstlisting}

As an aside we can notice that Nock 6 (like Nock 9) is defined as a combination of pseudocode operators and Nock opcodes. We can also go the other way to see what Nock 9 looks like in pure pseudocode operators.

\begin{lstlisting}[style=listingblock]
*[a 6 b c d] ==
  *[a *[[c d] 0 *[[2 3] 0 *[a 4 4 b]]]] ==
  *[a *[[c d] 0 *[[2 3] 0 ++*[a b]]]] ==
  *[a *[[c d] 0 /[++*[a b] [2 3]]]] ==
  *[a /[/[++*[a b] [2 3]] [c d]]]
\end{lstlisting}

\subsection*{Nock 6 Pseudocode Operator Equivalent}

\begin{lstlisting}[style=listingcode]
*[a 6 b c d] == *[a /[/[++*[a b] [2 3]] [c d]]]
\end{lstlisting}

This is not quite as intuitive as the Nock 9 pseudocode operator equivalent. The definition of Nock 6 is mostly to demonstrate the very cool fact that a branching operation can be derived using only the fundamental operators \lstinline[style=inlinecode]{*} tar, \lstinline[style=inlinecode]{/} fas and \lstinline[style=inlinecode]{+} lus. But we can also look at Nock 6 another way by introducing (in our own mental fork of the Nock spec) a new pseudocode operater \lstinline[style=inlinecode]{<} gal.

\subsection*{Nock 6 New Pseudocode Operator}

\begin{lstlisting}[style=listingcode]
<[0 a b]          a
<[1 a b]          b
<a                <a

*[a 6 b c d]      <[*[a b] *[a c] *[a d]]
\end{lstlisting}

This is equivalent to the original definition. Like \lstinline[style=inlinecode]{#} hax, this pseudocode operator is not required for Turing completeness. \lstinline[style=inlinecode]{*} tar, \lstinline[style=inlinecode]{?} wut, \lstinline[style=inlinecode]{+} lus, \lstinline[style=inlinecode]{=} tis, and \lstinline[style=inlinecode]{/} fas are enough for this. 

\section{Deriving Opcode 11}

Even though we don't need Nock 11 to build Nock 10, for the sake of our collective mania, let's note that Nock 11 can also trivially be written as a noun. The definition of Nock 11 is:

\begin{lstlisting}[style=listingcode]
*[a 11 [b c] d] == *[[*[a c] *[a d]] 0 3]
*[a 11 b c] ====== *[a c]
\end{lstlisting}

The hint provided by this code is used in the process of jetting. In the first case, an atomic tag \lstinline[style=inlinecode]{b} is provided and a formula \lstinline[style=inlinecode]{c} is used to compute additional hint information on the subject. \lstinline[style=inlinecode]{d} is the formula we are actually trying to compute. In the second case, only the atomic tag \lstinline[style=inlinecode]{b} is passed and \lstinline[style=inlinecode]{c} is the formula we are actually trying to compute.

It is tempting to try  to reduce the first case to \lstinline[style=inlinecode]{*[a d]}. However, this reduction is incorrect. You may have a case where \lstinline[style=inlinecode]{*[a c]} crashes but \lstinline[style=inlinecode]{*[a d]} does not. In this case, a correct interpreter will crash the whole expression if \lstinline[style=inlinecode]{*[a c]} crashes, whereas an incorrect interpreter will proceed with \lstinline[style=inlinecode]{*[a d]}. Thus, all correct interpreters must try
to compute \lstinline[style=inlinecode]{*[a c]}.

\begin{lstlisting}[style=listingblock]
*[a 11 [b c] d] == *[[*[a c] *[a d]] 0 3]
== *[*[a c d] *[a 1 0 3]]
== *[a 2 [c d] 1 0 3]

*[a 11 b c] == *[a c]
== *[*[a 0 1] *[a 1 c]]
== *[a 2 [0 1] 1 c]
\end{lstlisting}

\subsection*{Nock 11 Primitive Equivalent}

\begin{lstlisting}[style=listingcode]
*[a 11 [b c] d] == *[a 2 [c d] 1 0 3]
*[a 11 b c] ====== *[a 2 [0 1] 1 c]
\end{lstlisting}

\subsection*{Nock 11 Pseudocode Operator Equivalent}

\begin{lstlisting}[style=listingcode]
*[a 11 [b c] d] == /[3 [*[a c] *[a d]]]
*[a 11 b c] ====== *[a c]
\end{lstlisting}

\section{Explaining Opcode 10}

For convenience, let's restate Nock 10 and the \lstinline[style=inlinecode]{#} hax edit operator.

\begin{lstlisting}[style=listingcode]
*[a 10 [b c] d] ==  #[b *[a c] *[a d]]

#[1 a b] ============ a
#[(a + a) b c] ====== #[a [b /[(a + a + 1) c]] c]
#[(a + a + 1) b c] == #[a [/[(a + a) c] b] c]
\end{lstlisting}

\noindent
Nock 10 is defined in terms of the \lstinline[style=inlinecode]{#} hax edit operator. So let's derive this first.

\subsection{The \texttt{\#} edit operator}

Let's define \lstinline[style=inlinecode]{#} hax as a function of three inputs, \lstinline[style=inlinecode]{x}, \lstinline[style=inlinecode]{y}, and \lstinline[style=inlinecode]{z}. This says replace what's in slot \lstinline[style=inlinecode]{x} of \lstinline[style=inlinecode]{z} with \lstinline[style=inlinecode]{y}. In fact, let's rewrite the pseudocode with these inputs.

\begin{lstlisting}[style=listingblock]
#[(x := 1) y z] ========= y
#[(x : x is even) y z] == #[x/2 [y /[x+1 z]] z]
#[(x : x is odd) y z] === #[(x-1)/2 [/[x-1 z] y] z]
\end{lstlisting}

What are we doing here? Let's first note that there is really no way for us to ``edit" a noun. Really what we are doing is producing a new noun which is exactly the same as the old noun except in the specified way. If \lstinline[style=inlinecode]{x} is \lstinline[style=inlinecode]{1}, we are slotting into the root address of the noun \lstinline[style=inlinecode]{z} and replacing it with \lstinline[style=inlinecode]{y}, so we can get our "edited" noun simply by returning \lstinline[style=inlinecode]{y}. For any \lstinline[style=inlinecode]{x} greater than \lstinline[style=inlinecode]{1}, however, we have to create an entirely new noun. But creating complex nouns from scratch is hard. Creating a single \emph{cell}, on the other hand, is easy.

To make this easier to understand, let's say \lstinline[style=inlinecode]{v := /[x z]}. \lstinline[style=inlinecode]{v} is the noun we will be replacing with \lstinline[style=inlinecode]{y}; the current occupant of slot \lstinline[style=inlinecode]{x} in noun \lstinline[style=inlinecode]{z}.  This noun \lstinline[style=inlinecode]{v} has a "sibling noun" which we will call \lstinline[style=inlinecode]{w}. \lstinline[style=inlinecode]{v} is either the head or the tail of its "parent noun" \lstinline[style=inlinecode]{u}. Below, we diagram the two possible cases.
\newpage

\begin{lstlisting}[style=listingblock]
      z              z
     / \            / \
    *   *          *   *
   / \            / \
  u   *          u   *
 / \            / \
v   w          w   v
\end{lstlisting}

While we cannot create a modifed \lstinline[style=inlinecode]{z} in one step, we can create a modified \lstinline[style=inlinecode]{u} in one step. \lstinline[style=inlinecode]{u == [v w]} or \lstinline[style=inlinecode]{u == [w v]}. Since we are replacing \lstinline[style=inlinecode]{v} with \lstinline[style=inlinecode]{y}, our modified \lstinline[style=inlinecode]{u} looks like \lstinline[style=inlinecode]{u' == [y w]} in the first case and \lstinline[style=inlinecode]{u' == [w y]} in the second case. We already have \lstinline[style=inlinecode]{y}. We need to figure out how to get \lstinline[style=inlinecode]{w} and how to replace \lstinline[style=inlinecode]{u}. This requires the addresses of both. We diagram this below.

\begin{lstlisting}[style=listingblock]
nouns          slots
-----          -----
  u             x/2
 / \            / \ 
v   w          x  x+1

  u           (x-1)/2
 / \            / \
w   v         x-1  x
\end{lstlisting}

If \lstinline[style=inlinecode]{x} is even, \lstinline[style=inlinecode]{w} is in slot \lstinline[style=inlinecode]{x+1} of \lstinline[style=inlinecode]{z} and \lstinline[style=inlinecode]{u' == [y /[x+1 z]]} can be slotted into slot \lstinline[style=inlinecode]{x/2} of \lstinline[style=inlinecode]{z}. If \lstinline[style=inlinecode]{x} is odd, \lstinline[style=inlinecode]{w} is in slot \lstinline[style=inlinecode]{x-1} of \lstinline[style=inlinecode]{z} and \lstinline[style=inlinecode]{u' == [/[x-1 z] y]} can be slotted into slot \lstinline[style=inlinecode]{(x-1)/2} of \lstinline[style=inlinecode]{z}. A more concise way to say this would be:

\begin{lstlisting}[style=listingblock]
#[(x : x is even) y z] == #[x/2 [y /[x+1 z]] z]
#[(x : x is odd) y z] === #[(x-1)/2 [/[x-1 z] y] z]
\end{lstlisting}

This operation will recur, and since the slot is always getting smaller, we will eventually get to the base case of \lstinline[style=inlinecode]{x == 1} at which point we will return our new ``edited" noun.

Now let's translate this into Nock.  \emph{To perform this translation, we are going to make liberal use of Dojo variables to keep things relatively simple and modular.}

We are trying to recreate the \lstinline[style=inlinecode]{#} hax edit operator in a function called \lstinline[style=inlinecode]{#} hax which will take a subject \lstinline[style=inlinecode]{[x y z]}.  We should be able to run:

\begin{lstlisting}[style=listingblock]
*[[x y z] hax] == #[x y z]
\end{lstlisting}

\noindent
Let's crash immediately if \lstinline[style=inlinecode]{x} is a cell. This will make use of Nock 6. If \lstinline[style=inlinecode]{x-is-cell}, then \lstinline[style=inlinecode]{crash}; else \lstinline[style=inlinecode]{check-x-0} (we will proceed to check another degenerate case):

\begin{lstlisting}[style=listingblock]
*[[x y z] 6 x-is-cell crash check-x-0]
\end{lstlisting}

\noindent
For the sake of our \textsc{ocd}, we can start to convert this to opcodes 0 through 5 using our definition:

\begin{lstlisting}[style=listingcode]
*[a 6 b c d] == *[a 2 [0 1]
                      2 [1 c d] [1 0] 2 [1 2 3]
                                        [1 0] 4 4 b]
\end{lstlisting}

\begin{lstlisting}[style=listingblock]
=hax [2 [0 1] 2 [1 crash check-x-0]
                [1 0]
                2 [1 2 3] [1 0] 4 4 x-is-cell]
\end{lstlisting}

\noindent
To check if \lstinline[style=inlinecode]{x} is a cell, we use Nock 3:

\begin{lstlisting}[style=listingblock]
*[[x y z] 3 0 2]
=x-is-cell [3 0 2]
\end{lstlisting}

\noindent
To crash, we can simply try to slot into non-existing address \lstinline[style=inlinecode]{0}:

\begin{lstlisting}[style=listingblock]
*[[x y z] 0 0]
=crash [0 0]
\end{lstlisting}

\noindent
We should also crash if \lstinline[style=inlinecode]{x == 0}:

\begin{lstlisting}[style=listingblock]
*[[x y z] 6 x-is-0 crash launch]
=check-x-0 [2 [0 1] 2 [1 crash launch]
            [1 0] 2 [1 2 3] [1 0] 4 4 x-is-0]
\end{lstlisting}

\noindent
To check if \lstinline[style=inlinecode]{x == 0}, we use Nock 5:

\begin{lstlisting}[style=listingblock]
*[[x y z] 5 [0 2] 1 0]
=x-is-0 [5 [0 2] 1 0]
\end{lstlisting}

\noindent
In order to make recursive calls, we are going to want to store our formula in the head of our subject so that we can access it from within the formula.

\begin{lstlisting}[style=listingblock]
[hax-formula x y z]
\end{lstlisting}

\noindent
We can do this with Nock 8 and Nock 9. With Nock 8, we will pin \lstinline[style=inlinecode]{hax-formula} to the head of the subject and then call this head on the modified subject using Nock 9.

\begin{lstlisting}[style=listingblock]
*[[x y z] 8 [1 hax-formula] call-head]
\end{lstlisting}

\noindent
Recall that \lstinline[style=inlinecode]{*[a 8 b c] == *[a 2 [b 0 1] 1 c]}.

\begin{lstlisting}[style=listingblock]
=launch [2 [[1 hax-formula] 0 1] 1 call-head]
\end{lstlisting}

\noindent
To call the head of the modified subject on itself:

\begin{lstlisting}[style=listingblock]
*[[hax-formula x y z] 9 2 0 1]
\end{lstlisting}

\noindent
Recall that \lstinline[style=inlinecode]{*[a 9 b c] == *[a 2 c 1 2 [0 1] 0 b]}.

\begin{lstlisting}[style=listingblock]
*[[hax-formula x y z] 9 2 0 1] ==
  [[hax-formula x y z] 2 [0 1] 1 2 [0 1] 0 2]
\end{lstlisting}

\noindent
Notice that this simplifies to:

\begin{lstlisting}[style=listingblock]
=call-head [2 [0 1] 0 2]
\end{lstlisting}

Now let's develop \lstinline[style=inlinecode]{hax-formula}. The subject we are now dealing with has the form:

\begin{lstlisting}[style=listingblock]
[hax-formula x y z]
\end{lstlisting}

\begin{itemize}
  \item \lstinline[style=inlinecode]{hax-formula} is at slot \lstinline[style=inlinecode]{2} (the head).
  \item \lstinline[style=inlinecode]{x} is at slot \lstinline[style=inlinecode]{6} (the head of the tail).
  \item \lstinline[style=inlinecode]{y} is at slot \lstinline[style=inlinecode]{14}.
  \item \lstinline[style=inlinecode]{z} is at slot \lstinline[style=inlinecode]{15}.
\end{itemize}

\noindent
Let's deal with the first real branch.  If \lstinline[style=inlinecode]{x == 1}, then we return \lstinline[style=inlinecode]{y}; else, we \lstinline[style=inlinecode]{recur-hax}:

\begin{lstlisting}[style=listingblock]
*[[hax-formula x y z] 6 x-is-1 return-y recur-hax]
=hax-formula [2 [0 1] 2 [1 return-y recur-hax]
                        [1 0]
                        2 [1 2 3] [1 0] 4 4 x-is-1]
=x-is-1 [5 [0 6] 1 1]
=return-y [0 14]
\end{lstlisting}

\noindent
Excellent. Now we are getting to the recursive part of our algorithm. We have already dealt with the base case. Now in the non-base case we want to call \lstinline[style=inlinecode]{hax-formula} on new parameters \lstinline[style=inlinecode]{[new-x new-y new-z]}. Let us imagine that there is a function \lstinline[style=inlinecode]{new-params} which takes subject \lstinline[style=inlinecode]{[x y z]} and returns \lstinline[style=inlinecode]{[new-x new-y new-z]}.  We can write this function later.

First, we want to create a cell:

\begin{lstlisting}[style=listingblock]
[hax-formula new-x new-y new-z] ==
  [hax-formula *[[x y z] new-params]]

*[[hax-formula x y z] [0 2] 2 [0 3] 1 new-params]
=new-cell [[0 2] 2 [0 3] 1 new-params]
\end{lstlisting}

\noindent
And we want to call the head of this new cell on itself:

\begin{lstlisting}[style=listingblock]
*[[hax-formula x y z] 9 2 new-cell]
=recur-hax [2 new-cell 1 2 [0 1] 0 2]
\end{lstlisting}

\noindent
When trying to extract new parameters from \lstinline[style=inlinecode]{[x y z]}, we come to another branch. We know at this point that \lstinline[style=inlinecode]{x} is not a cell and \lstinline[style=inlinecode]{x > 1}. Now we need to check if \lstinline[style=inlinecode]{x} is even:

\begin{itemize}
  \item  If \lstinline[style=inlinecode]{x} is even, return the following parameter updates:

\begin{lstlisting}[style=listingblock]
x := x/2
y := [y /[x+1 z]]
z := z
\end{lstlisting}

  \item  Else (if \lstinline[style=inlinecode]{x} is odd), return the following parameter updates:

\begin{lstlisting}[style=listingblock]
x := (x-1)/2
y := [/[x-1 z] y]
z := z
\end{lstlisting}

\end{itemize}

\noindent
So there are basically three things we need. We need a decremented \lstinline[style=inlinecode]{x}, \lstinline[style=inlinecode]{x-1}. We need a loobean which returns \lstinline[style=inlinecode]{0} if \lstinline[style=inlinecode]{x} is even and \lstinline[style=inlinecode]{1} otherwise (if \lstinline[style=inlinecode]{x} is odd; we have already dealt with all other cases). And we need the floor of half of \lstinline[style=inlinecode]{x}---the ``parent address" of \lstinline[style=inlinecode]{x}.

We can actually get all of these at the same time. By using a modified version of the decrement algorithm, we can count up to \lstinline[style=inlinecode]{x-1} using some \lstinline[style=inlinecode]{counter} variable, keep track of whether \lstinline[style=inlinecode]{counter+1} is even or odd in variable \lstinline[style=inlinecode]{iseven} and keep track of the ``parent address" of \lstinline[style=inlinecode]{counter+1} in variable \lstinline[style=inlinecode]{floorhalf}. When we get to \lstinline[style=inlinecode]{counter == x-1} we will have \lstinline[style=inlinecode]{x-1}, whether \lstinline[style=inlinecode]{x} is even, and the floor of half of \lstinline[style=inlinecode]{x}.

Because we are dealing with \lstinline[style=inlinecode]{x} values greater than \lstinline[style=inlinecode]{1}, the initial value of \lstinline[style=inlinecode]{counter} is \lstinline[style=inlinecode]{1}. Since the initial value of \lstinline[style=inlinecode]{counter+1} is \lstinline[style=inlinecode]{2} (the lowest possible value of \lstinline[style=inlinecode]{x}), the initial value of \lstinline[style=inlinecode]{iseven} is \lstinline[style=inlinecode]{0} and the initial value of \lstinline[style=inlinecode]{floorhalf} is \lstinline[style=inlinecode]{1}.

Here is what this looks like counting up to 10:

\begin{lstlisting}[style=listingblock]
                     -------
                     x == 10
                     -------
+(counter)  2  3  4  5  6  7  8  9 10
counter     1  2  3  4  5  6  7  8  9
iseven      0  1  0  1  0  1  0  1  0
floorhalf   1  1  2  2  3  3  4  4  5
\end{lstlisting}

\noindent
Let's look at the format of our function. Our subject is \lstinline[style=inlinecode]{[x y z]}. We are going to pin \lstinline[style=inlinecode]{[counter iseven floorhalf]} to the head of this noun and then our \lstinline[style=inlinecode]{params-formula} for recursion to the head of that. So by the time our recursion starts, our subject will look like this:

\begin{lstlisting}[style=listingblock]
[params-formula [counter iseven floorhalf] x y z]
\end{lstlisting}

\noindent
To pin \lstinline[style=inlinecode]{[[counter == 1] [iseven == 0] [floorhalf == 1]]} to the head of subject \lstinline[style=inlinecode]{[x y z]}, we run:

\begin{lstlisting}[style=listingblock]
*[[x y z] 8 [1 1 0 1] pin-formula] ==
  *[[[1 0 1] x y z] pin-formula]
=new-params [2 [[1 1 0 1] 0 1] 1 pin-formula]
\end{lstlisting}

\noindent
Next, we want to pin our \lstinline[style=inlinecode]{params-formula} to the head of this new subject:

\begin{lstlisting}[style=listingblock]
*[[[1 0 1] x y z] 8 [1 params-formula] call-head] ==
  *[[params-formula [1 0 1] x y z] call-head]
=pin-formula [2 [[1 params-formula] 0 1] 1 call-head]
\end{lstlisting}

\noindent
Finally, we want to run this \lstinline[style=inlinecode]{params-formula}, which is in the head of this new subject, against the whole subject. We actually already created a function which accomplishes this. We called it \lstinline[style=inlinecode]{call-head}.

\begin{lstlisting}[style=listingblock]
call-head == [2 [0 1] 0 2]
\end{lstlisting}

Okay. Now we're ready to develop \lstinline[style=inlinecode]{params-formula}, which operates on subject:

\begin{lstlisting}[style=listingblock]
[params-formula [counter iseven floorhalf] x y z]
\end{lstlisting}

\noindent
(To save space we will write this as \lstinline[style=inlinecode]{[pf [c i f] x y z]}.)

\begin{itemize}
  \item \lstinline[style=inlinecode]{params-formula} is at slot \lstinline[style=inlinecode]{2} (the head).
  \item \lstinline[style=inlinecode]{counter} is at slot \lstinline[style=inlinecode]{12} (the head of the head of the tail).
  \item \lstinline[style=inlinecode]{iseven} is at slot \lstinline[style=inlinecode]{26}.
  \item \lstinline[style=inlinecode]{floorhalf} is at slot \lstinline[style=inlinecode]{27}.
  \item \lstinline[style=inlinecode]{x} is at slot \lstinline[style=inlinecode]{14}.
  \item \lstinline[style=inlinecode]{y} is at slot \lstinline[style=inlinecode]{30}.
  \item \lstinline[style=inlinecode]{z} is at slot \lstinline[style=inlinecode]{31}.
\end{itemize}

Our formula should check if \lstinline[style=inlinecode]{counter+1 == x}. If this is the case, we have all the necessary data and we can \lstinline[style=inlinecode]{return-params}. Else, we should increment \lstinline[style=inlinecode]{counter}, flip \lstinline[style=inlinecode]{iseven} from \lstinline[style=inlinecode]{0} to \lstinline[style=inlinecode]{1} or from \lstinline[style=inlinecode]{1} to \lstinline[style=inlinecode]{0}, increment \lstinline[style=inlinecode]{floorhalf} only if \lstinline[style=inlinecode]{iseven == 1}, and then run \lstinline[style=inlinecode]{params-formula} again. You should be able to convince yourself that this works.

\begin{lstlisting}[style=listingblock]
*[[pf [c i f] x y z] 6 is-at-x return-params recur-pf]
=params-formula [2 [0 1] 2 [1 return-params recur-pf]
                           [1 0]
                           2 [1 2 3]
                             [1 0]
                             4 4 is-at-x]

=is-at-x [5 [0 14] 4 0 12]
\end{lstlisting}

To return parameters from \lstinline[style=inlinecode]{[pf [c i f] x y z]} we need to branch on \lstinline[style=inlinecode]{iseven}.

\begin{lstlisting}[style=listingblock]
*[[pf [c i f] x y z] 6 iseven even-params odd-params]
=iseven [0 26]
=return-params [2 [0 1] 2 [1 even-params odd-params]
                          [1 0] 2 [1 2 3]
                                  [1 0] 4 4 iseven]
\end{lstlisting}

\noindent
Recall that if \lstinline[style=inlinecode]{x} is even, return the following parameter updates:

\begin{lstlisting}[style=listingblock]
x := x/2
y := [y /[x+1 z]]
z := z
\end{lstlisting}

\noindent
else (if \lstinline[style=inlinecode]{x} is odd), return the following parameter updates:

\begin{lstlisting}[style=listingblock]
x := (x-1)/2
y := [/[x-1 z] y]
z := z
\end{lstlisting}

\noindent
This translates to the logic:  If \lstinline[style=inlinecode]{iseven} is \lstinline[style=inlinecode]{0}, return:
\begin{lstlisting}[style=listingblock]
[floorhalf [y /[+(x) z]] z]
\end{lstlisting}
else, return:
\begin{lstlisting}[style=listingblock]
[floorhalf [/[counter z] y] z]
\end{lstlisting}

Let's try to build these cells:

\begin{lstlisting}[style=listingblock]
+(x) == *[[pf [c i f] x y z] 4 0 14]
counter == *[[pf [c i f] x y z] 0 12]
z == *[[pf [c i f] x y z] 0 31]

/[+(x) z] == *[z 0 +(x)] ==
  *[*[[pf [c i f] x y z] 0 31]
    *[[pf [c i f] x y z] [1 0] 4 0 14]] ==
  *[[pf [c i f] x y z] 2 [0 31] [1 0] 4 0 14]

/[counter z] == *[z 0 counter]
== *[*[[pf [c i f] x y z] 0 31]
     *[[pf [c i f] x y z] [1 0] 0 12]]
== *[[pf [c i f] x y z] 2 [0 31] [1 0] 0 12]

[floorhalf [y /[+(x) z]] z]
== *[[pf [c i f] x y z] [0 27]
     [[0 30] 2 [0 31] [1 0] 4 0 14] 0 31]
=even-params [[0 27] [[0 30] 2 [0 31] [1 0] 4 0 14]
              0 31]

[floorhalf [/[counter z] y] z]
== *[[pf [c i f] x y z] [0 27]
     [[2 [0 31] [1 0] 0 12] 0 30] 0 31]
=odd-params [[0 27] [[2 [0 31] [1 0] 0 12] 0 30]
             0 31]
\end{lstlisting}

\noindent
All right, we now have a formula to return new parameters when \lstinline[style=inlinecode]{x} is even and a formula to return new parameters when \lstinline[style=inlinecode]{x} is odd.

Now we need to actually get our modified decrement to count up to \lstinline[style=inlinecode]{x-1}, updating our other data with it. Remember, our \lstinline[style=inlinecode]{recur-pf} formula will be operating on subject:  

\begin{lstlisting}[style=listingblock]
[params-formula [counter iseven floorhalf] x y z]
\end{lstlisting}

\noindent
We want to call \lstinline[style=inlinecode]{params-formula} on:

\begin{lstlisting}[style=listingblock]
[params-formula [new-counter new-iseven
                 new-floorhalf] x y z]
\end{lstlisting}

\noindent
We can do this by calling:

\begin{lstlisting}[style=listingblock]
*[[pf [c i f] x y z] 9 2 [0 2]
  [new-counter new-iseven new-floorhalf] 0 7]
\end{lstlisting}

\noindent
\lstinline[style=inlinecode]{[[0 2] [new-counter new-iseven new-floorhalf 0 7]]} creates the new subject as a cell and the opcode 9 launches the head \lstinline[style=inlinecode]{2} on this new subject.

\begin{lstlisting}[style=listingblock]
=recur-pf [2 [[0 2]
              [new-counter new-iseven new-floorhalf]
              0 7] 1 2 [0 1] 0 2]
\end{lstlisting}

\noindent
Now let's actually update these values. \lstinline[style=inlinecode]{new-counter} is easy enough. It just increments the existing counter.

\begin{lstlisting}[style=listingblock]
=new-counter [4 0 12]
\end{lstlisting}

\noindent
\lstinline[style=inlinecode]{new-iseven} checks \lstinline[style=inlinecode]{iseven} then returns \lstinline[style=inlinecode]{1} if yes or \lstinline[style=inlinecode]{0} if no.

\begin{lstlisting}[style=listingblock]
*[[pf [c i f] x y z] 6 iseven [1 1] 1 0]
=new-iseven [2 [0 1] 2 [1 [1 1] 1 0] [1 0]
             2 [1 2 3] [1 0] 4 4 iseven]
\end{lstlisting}

\noindent
\lstinline[style=inlinecode]{new-floorhalf} checks \lstinline[style=inlinecode]{iseven} and returns \lstinline[style=inlinecode]{floorhalf} if yes or \lstinline[style=inlinecode]{+(floorhalf)} if no.

\begin{lstlisting}[style=listingblock]
*[[pf [c i f] x y z] 6 iseven [0 27] 4 0 27]
=new-floorhalf [2 [0 1] 2 [1 [0 27] 4 0 27] [1 0]
                2 [1 2 3] [1 0] 4 4 iseven]
\end{lstlisting}

\noindent
Okay! We have written our \lstinline[style=inlinecode]{#} hax edit operator as a Nock formula consisting of only Nocks 0 through 5. Very exciting! Let's put it together and see what it looks like. If you would like to try this yourself, copy and paste the following code in the dojo.

\begin{lstlisting}[style=listingcode]
=iseven [0 26]
=new-counter [4 0 12]
=new-iseven [2 [0 1] 2 [1 [1 1] 1 0] [1 0]
             2 [1 2 3] [1 0] 4 4 iseven]
=new-floorhalf [2 [0 1] 2 [1 [0 27] 4 0 27] [1 0]
                2 [1 2 3] [1 0] 4 4 iseven]
=recur-pf [2 [[0 2]
              [new-counter new-iseven new-floorhalf]
              0 7] 1 2 [0 1] 0 2] 
=odd-params [[0 27] [[2 [0 31] [1 0] 0 12] 0 30]
             0 31]
=even-params [[0 27] [[0 30] 2 [0 31] [1 0] 4 0 14]
              0 31]
=return-params [2 [0 1] 2 [1 even-params odd-params]
                [1 0] 2 [1 2 3] [1 0] 4 4 iseven]
=is-at-x [5 [0 14] 4 0 12]
=params-formula [2 [0 1] 2 [1 return-params recur-pf]
                 [1 0] 2 [1 2 3] [1 0] 4 4 is-at-x]
=call-head [2 [0 1] 0 2]
=pin-formula [2 [[1 params-formula] 0 1] 1 call-head]
=new-params [2 [[1 1 0 1] 0 1] 1 pin-formula]
=new-cell [[0 2] 2 [0 3] 1 new-params]
=recur-hax [2 new-cell 1 2 [0 1] 0 2]
=x-is-1 [5 [0 6] 1 1]
=return-y [0 14]
=hax-formula [2 [0 1] 2 [1 return-y recur-hax]
              [1 0] 2 [1 2 3] [1 0] 4 4 x-is-1]
=launch [2 [[1 hax-formula] 0 1] 1 call-head]
=x-is-0 [5 [0 2] 1 0]
=crash [0 0]
=check-x-0 [2 [0 1] 2 [1 crash launch] [1 0]
            2 [1 2 3] [1 0] 4 4 x-is-0]
=x-is-cell [3 0 2]

=hax [2 [0 1] 2 [1 crash check-x-0] [1 0] 2 [1 2 3]
      [1 0] 4 4 x-is-cell]
\end{lstlisting}

\noindent
Great! What does this look like?

\newpage
\begin{lstlisting}[style=listingcode]
::  hax definition in raw Nock
[2 [0 1]
   2 [1 [0 0]
      2 [0 1]
        2 [1 [0 0]
           2 [[1 2 [0 1]
                   2 [1 [0 14]
                      2 [[0 2]
                         2 [0 3]
                         1 2 [[1 1 0 1] 0 1]
                             1 2 [[1 2 [0 1]
                                   2 [1 [2 [0 1]
                                           2 [1
  ↳ [[0 27] [[0 30] 2 [0 31] [1 0] 4 0 14] 0 31]
   [0 27]
   [[2 [0 31] [1 0] 0 12] 0 30]
                                              0 31]
                                             [1 0]
                                           2 [1 2 3]
                                             [1 0]
                                             4 4 0 26]
                                      2 [[0 2]
                                         [[4 0 12]
  ↳ [2 [0 1]
       2 [1 [1 1] 1 0]
         [1 0]
         2 [1 2 3]
           [1 0]
           4 4 0 26]
    2 [0 1]
      2 [1 [0 27] 4 0 27]
        [1 0]
        2 [1 2 3]
          [1 0]
          4 4 0 26]
                                         0 7]
                                      1 2 [0 1]
                                      0 2]
                                     [1 0]
                                     2 [1 2 3]
                                       [1 0]
                                       4 4 5 [0 14]
                                   4 0 12]
                                  0 1]
                           1 2 [0 1]
                         0 2]
                        1 2 [0 1]
                       0 2]
                    [1 0]
            2 [1 2 3]
              [1 0]
              4 4 5 [0 6]
                1 1]
            0 1]
          1 2 [0 1]
        0 2]
      [1 0]
      2 [1 2 3]
        [1 0]
      4 4 5 [0 2]
      1 0]
  [1 0]
  2 [1 2 3]
    [1 0]
    4 4 3 0 2]
\end{lstlisting}

\noindent
Quite a mouthful. I don't think this one will fit on a t-shirt. 
Maybe an evening gown, or perhaps a toga.

So, does it work?

\begin{lstlisting}[style=listingcode]
> .*([1 [4 5] 6 7 8 9 10 11 12 13] hax)
[4 5]

> .*([2 [4 5] 6 7 8 9 10 11 12 13] hax)
[[4 5] 7 8 9 10 11 12 13]

> .*([3 [4 5] 6 7 8 9 10 11 12 13] hax)
[6 4 5]

> .*([62 [4 5] 6 7 8 9 10 11 12 13] hax)
[6 7 8 9 [4 5] 11 12 13]

> .*([17 [4 5] [[[[[[[6] 7] 8] 9] 10] 11] 12] 13]
     hax)
[[[[[[[6 7] 8] 9] 4 5] 11] 12] 13]
\end{lstlisting}

It appears so! We are inches away from the finish line.

\section{Deriving Opcode 10}

We now have our \lstinline[style=inlinecode]{#} hax operator. The last thing we have to do is use it to create a Nock 10 which runs on subject \lstinline[style=inlinecode]{a} with parameters \lstinline[style=inlinecode]{b}, \lstinline[style=inlinecode]{c}, and \lstinline[style=inlinecode]{d}:

\begin{lstlisting}[style=listingcode]
*[a 10 [b c] d] == #[b *[a c] *[a d]]
\end{lstlisting}

\noindent
Recall that we wrote \lstinline[style=inlinecode]{#} hax such that:

\begin{lstlisting}[style=listingblock]
*[[x y z] hax] == #[x y z]
\end{lstlisting}

\noindent
We can now rewrite this as:

\begin{lstlisting}[style=listingblock]
*[a 10 [b c] d] ==
  *[[b *[a c] *[a d]] hax] ==
  *[[*[a 1 b] *[a c d]] *[a 1 hax]] ==
  *[*[a [1 b] c d] *[a 1 hax]] ==
  *[a 2 [[1 b] c d] 1 hax]
=nock-ten [2 [[1 b] c d] 1 hax]
\end{lstlisting}

\noindent
And that's it. Congratulations! You have now derived all the Nock opcodes from 6 to 11 using only opcodes 0 through 5. What you will accomplish with this knowledge, I tremble to imagine. \tombstone

\newpage
\subsection*{Nock 10 Primitive Equivalent}

\begin{lstlisting}[style=listingcode]
*[a 10 [b c] d] ==
*[a 2 [[1 b] c d]
      1 2 [0 1]
          2 [1 [0 0]
             2 [0 1]
               2 [1 [0 0]
                  2 [[1 2 [0 1]
                      2 [1 [0 14]
                         2 [[0 2]
                            2 [0 3]
                        1 2 [[1 1 0 1] 0 1]
                        1 2 [[1 2 [0 1]
 ↳  2 [1 [2 [0 1]
          2 [1 [[0 27]
                [[0 30]
                  2 [0 31]
                    [1 0]
                    4 0 14]
                0 31]
                [0 27]
                [[2 [0 31]
                    [1 0]
                    0 12]
                  0 30]
              0 31]
              [1 0]
              2 [1 2 3]
                [1 0]
                4 4 0 26]
          2 [[0 2]
             [[4 0 12]
              [2 [0 1]
                  2 [1 [1 1] 1 0]
                    [1 0]
                    2 [1 2 3]
                      [1 0]
                      4 4 0 26]
              2 [0 1]
              2 [1 [0 27] 4 0 27]
                [1 0]
                2 [1 2 3]
                  [1 0]
                  4 4 0 26]
              0 7]
       1 2 [0 1] 0 2]
       [1 0]
       2 [1 2 3]
         [1 0]
         4 4 5 [0 14] 4 0 12]
                              0 1]
                          1 2 [0 1] 0 2]
               1 2 [0 1] 0 2]
          [1 0]
          2 [1 2 3]
            [1 0]
            4 4 5 [0 6]
          1 1]
        0 1]
      1 2 [0 1] 0 2]
    [1 0]
    2 [1 2 3]
      [1 0]
      4 4 5 [0 2] 1 0]
  [1 0]
  2 [1 2 3]
    [1 0]
    4 4 3 0 2]
\end{lstlisting}

\selectlanguage{USenglish}
% \printbibliography
\end{document}
